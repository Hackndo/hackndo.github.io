---
title: 'wget &#038;&#038; segfault &#8211; RÃ©sumÃ©'
date: 2015-06-11
author: "HackN'Do"
layout: post
permalink: /wget-segfault-resume/
image: /assets/uploads/2015/06/WGETSEGFAULT.jpg
categories:
  - Hacking
  - UNIX
---
Salut Ã  tous, **winw** m'a montrÃ© rÃ©cemment un truc assez sympa. Dans un terminal, tapez la commande

<pre class="lang:sh decode:true">$ wget -r %3a
Segmentation fault</pre>

Vous obtiendrez un segfault. C'est assez sympa, d'autant plus que wget est quand mÃªme un binaire largement utilisÃ©. Les bugs comme celui-ci se font rares ! On s'est alors demandÃ© ce qu'on pourrait bien en faire. Nous ne nous sommes donc pas arrÃªtÃ©s lÃ , et on a cherchÃ© la cause du problÃ¨me. Pour cela, nous nous sommes armÃ©s de ce bon vieux gdb, ainsi que des sources de la derniÃ¨re version de wget en date (1.16.3) disponible ici :

<http://ftp.gnu.org/gnu/wget/wget-1.16.3.tar.gz>

Dans un premier temps, nous avons recompilÃ© le binaire afin d'en avoir une version non strippÃ©e et donc avoir accÃ¨s aux symboles. Dans le dossiers des sources de wget :

<pre lang="sh">$ ./configure --user-prefix=/home/hackndo/wget
$ make && sudo make install</pre>

Ensuite nous avons provoquÃ© le segfault dans gdb puis affichÃ© la backtrace pour trouver oÃ¹ se situe le problÃ¨me

<pre lang="sh">gdb$ r -r %3a
warning: no loadable sections found in added symbol-file system-supplied DSO at 0x7ffff7ffa000
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Program received signal SIGSEGV, Segmentation fault.
-----------------------------------------------------------------------------------------------------------------------[regs]
RAX: 0x0000000000000006Â  RBX: 0x0000000000000000Â  RBP: 0x000000000065FFE0Â  RSP: 0x00007FFFFFFFDF10Â  o d I t s z a p c
RDI: 0x00000000FFFFFFFFÂ  RSI: 0x00007FFFF7FF7000Â  RDX: 0x00007FFFF799CDF0Â  RCX: 0x00007FFFF76E59D0Â  RIP: 0x0000000000421ADB
R8 : 0x00007FFFF7FF7001Â  R9 : 0x00007FFFF7FE9700Â  R10: 0x0000000000000000Â  R11: 0x0000000000000246Â  R12: 0x000000000065FFB0
R13: 0x000000000065F950Â  R14: 0x00007FFFFFFFE05AÂ  R15: 0x00007FFFFFFFE060
CS: 0033Â  DS: 0000Â  ES: 0000Â  FS: 0000Â  GS: 0000Â  SS: 002B
-----------------------------------------------------------------------------------------------------------------------</pre>

<pre lang="sh">=> 0x421adb <getproxy+27>:Â  movÂ Â Â  esi,DWORD PTR [rbx+0x18]
   0x421ade <getproxy+30>:Â  movÂ Â Â  edi,0x44af12
   0x421ae3 <getproxy+35>:Â  xorÂ Â Â  eax,eax
   0x421ae5 <getproxy+37>:Â  callÂ Â  0x402f10 <printf@plt>
   0x421aea <getproxy+42>:Â  movÂ Â Â  rdi,QWORD PTR [rip+0x23b2bf]Â Â Â Â Â Â Â  # 0x65cdb0 <opt+304>
   0x421af1 <getproxy+49>:Â  movÂ Â Â  rsi,QWORD PTR [rbx+0x10]
   0x421af5 <getproxy+53>:Â  testÂ Â  rdi,rdi
   0x421af8 <getproxy+56>:Â  jeÂ Â Â Â  0x421b03 <getproxy+67>
-----------------------------------------------------------------------------------------------------------------------------
0x0000000000421adb in getproxy ()
gdb$ bt
#0Â  0x0000000000421adb in getproxy ()
#1Â  0x00000000004226fa in retrieve_url ()
#2Â  0x00000000004204a0 in retrieve_tree ()
#3Â  0x0000000000404168 in main ()</pre>

&nbsp;

Le segfault se produit dans la fonction _getproxy_ se trouvant dans **retr.c**

<pre lang="c">getproxy (struct url *u)</pre>

AprÃ¨s quelques petites recherches, on remarque que le pointeur u sur une structure _url_ est un pointeur null, et du coup Ã  la ligne

<pre lang="c">if (no_proxy_match (u->host, (const char **)opt.no_proxy))</pre>

la tentative d'accÃ¨s au champ _host_ de la structure provoque le segfault.

TrÃ¨s bien, nous avons isolÃ© la cause du segfault. Cependant, comment se fait-il que le pointeur u passÃ© Ã  _getproxy_ soit nul ? Nous remontons alors un peu la backtrace.
  
Dans _retrieve_url_, toujours dans le mÃªme fichier

<pre lang="c">uerr_t retrieve_url (struct url * orig_parsed, const char *origurl, char **file,
char **newloc, const char *refurl, int *dt, bool recursive,
struct iri *iri, bool register_status)</pre>

On voit l'appel Ã  _getproxy_

<pre lang="c">proxy = getproxy (u);</pre>

Et on voit plus haut que _u_ est dÃ©fini comme ceci :

<pre lang="c">struct url *u = orig_parsed</pre>

En mettant un breakpoint Ã  l'entrÃ©e de la fonction _retrieve_url,_ on se rend compte que le paramÃ¨tre _orig_parsed_ est dÃ©jÃ  un pointeur nul. On continue et on remonte la backtrace d'un cran, en allant voir la fonction _retrieve_treeÂ _situÃ© dans le fichierÂ **recur.c**

<pre lang="c">uerr_t retrieve_tree (struct url *start_url_parsed, struct iri *pi)</pre>

On voit l'appel Ã  la fonction _retrieve_url_ ici

<pre lang="c">status = retrieve_url (url_parsed, url, &file, &redirected, referer,
&dt, false, i, true);</pre>

Nous avons dit que le paramÃ¨tre _url_parsed_ Ã©tait nul. Ce pointeur est dÃ©fini une ligne au dessus :

<pre lang="c">struct url *url_parsed = url_parse (url, &url_err, i, true);</pre>

Cette fois-ci, aucun des paramÃ¨tres passÃ©s Ã  _url_parse_ ne sont nuls. Cette fonction renvoie donc un pointeur nul. En mettant un breakpoint juste aprÃ¨s l'appel Ã  cette fonction, on peut voir ce qu'il y a dans _url_err_ : Le numÃ©ro 8.
  
Le code d'erreur 8 est dÃ©fini dans le fichier **url.c** (dans lequel il y a la fonction _url_parse_)

<pre lang="c">#define PE_INVALID_IPV6_ADDRESSÂ Â Â Â Â Â Â Â  8</pre>

Effectivement, dans la fonction _url_parse_, nous avons la vÃ©rification suivante :

<pre lang="c" class="">/* Check if the IPv6 address is valid. */
if (!is_valid_ipv6_address(host_b, host_e))
{
    error_code = PE_INVALID_IPV6_ADDRESS;
    goto error;
}

/* Continue parsing after the closing ']'. */</pre>

Je vous rappelle que l'argument que nous avons passÃ© Ã  wget Ã©tait **-r %3a** or **%3a** est le code ASCII de **:** . En amont, wget a dÃ©tectÃ© notreÂ **:** et a donc considÃ©rÃ© que c'Ã©tait une adresse IPv6. Celle-ci Ã©tant invalide, _i_) renvoie _false_, et nous avons le code d'erreur. Tout est bien et se passe comme prÃ©vu par les dÃ©veloppeurs Ã  ce moment lÃ .

L'erreur, c'est dans le fichier **recur.c** avec ces lignes :

<pre lang="c">struct url *url_parsed = url_parse (url, &url_err, i, true);
status = retrieve_url (url_parsed, url, &file, &redirected, referer,
&dt, false, i, true);</pre>

Il n'y a aucune vÃ©rification de faite sur le retour de la fonction _url_parse_, et le pointeur _url_parsed_ est utilisÃ© sans vÃ©rifier s'il est nul, ou non.
  
Nous avons donc, logiquement, un segfault. De notre point de vue, cet oubli ne permet aucune exploitation, mais c'Ã©tait une analyse intÃ©ressante. Un fix est de vÃ©rifier que la fonction _url_parse_ a renvoyÃ© un pointeur non nul, de la maniÃ¨re suivante :

<pre lang="c" class="">struct url *url_parsed = url_parse (url, &url_err, i, true);

if (!url_parsed)
{
    char *error = url_error (url, url_err);
    logprintf (LOG_NOTQUIET, "%s: %s.\n",url, error);
    xfree (error);
    inform_exit_status (URLERROR);
}
else
{
    status = retrieve_url (url_parsed, url, &file, &redirected, referer,
    &dt, false, i, true);
    // [...]</pre>

Nous avons d'ailleurs proposÃ© un fix Ã  GNU. Nous verrons s'il sera acceptÃ© !

Ce problÃ¨me n'existe pas si le paramÃ¨tre **-r** est omis, puisque cet oubli de vÃ©rification se situe seulement dans le fichier **recur.c**, et nulle part ailleurs.

**Edit** : Petite mise Ã  jour, le fix que nous avons proposÃ© a Ã©tÃ© acceptÃ© et [est mergÃ© dans la branche master](https://savannah.gnu.org/bugs/?45289#comment5) ! VoilÃ , une petite contribution au monde libre, Ã§a fait plaisir ğŸ™‚